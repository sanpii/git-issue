#!/bin/sh

USAGE='[help|init|new|show|edit]'
LONG_USAGE='git issue help
    print long help message.
git issue init
    initialize the issue tracker.
git issue new
    create a new issue.
git issue show <id>
    display issue #id.
git issue edit <id>
    edit issue #id.'

OPTIONS_SPEC=
. git-sh-setup

OLD_REV=$(git rev-parse --abbrev-ref HEAD)
ISSUE_BRANCH=$(git config --get issue.branch || echo 'issues')

QUIET=false

# {{{ Shell common
function_exists()
{
    function=$1

    type $function > /dev/null 2>&1
}

info()
{
    $QUIET || echo "$@"
}

warn()
{
    $QUIET || echo "$@" >&2;
}

die()
{
    warn "$@"
    exit 1
}
# }}}
# {{{ Git common
git_local_branch_exists()
{
    local name=$1

    git branch --no-color | grep -q "$name"
}

git_have_changes()
{
    test -n "$(git status --porcelain)"
}

git_issue_parse_args()
{
    while getopts ":q" opt
    do
        case $opt in
            q)
                QUIET=true
            ;;
            \?)
                die "Invalid option: -$OPTARG"
            ;;
        esac
    done
}
# }}}
# {{{ Git issue common
git_issue_get_last_id()
{
    local id=$(ls -1 | grep '[0-9]\+' | sort -n | tail -1)

    if [ -z $id ]
    then
        id=0
    fi
    echo $id
}

git_issue_switch_branch()
{
    git_local_branch_exists $ISSUE_BRANCH || die 'Git issue not initialized.'
    git_have_changes && die "You have unstaged changes.\nPlease commit or stash them."

    git checkout -q $ISSUE_BRANCH
}

git_issue_restore_branch()
{
    git checkout -q $OLD_REV
}
# }}}
# {{{ Commands
git_issue_help()
{
    git issue -h
}

git_issue_init()
{
    git_local_branch_exists $ISSUE_BRANCH && die 'Git issue already initialized.'
    git_have_changes && die "Cannot initialized: You have unstaged changes.\nPlease commit or stash them."

    git checkout -q --orphan $ISSUE_BRANCH
    [ -n "$(git ls-files)" ] && git rm -qf $(git ls-files)
    git commit -q --allow-empty -m 'git issue init'

    info 'Git issue initialized.'
}

git_issue_new()
{
    local id=$(expr $(git_issue_get_last_id) + 1)

    touch "$id"
    git add "$id"
    git commit -q -m "Create issue #${id}"

    info "Issue #${id} created."
}

git_issue_show()
{
    local id="$1"

    [ -f "$id" ] || die "Issue #${id} doesn't exist"
    cat $id
}

git_issue_edit()
{
    local id="$1"

    [ -f "$id" ] || die "Issue #${id} doesn't exist"

    GIT_EDITOR=$(git var GIT_EDITOR)
    eval "$GIT_EDITOR '$id'"

    git_have_changes && git commit -q -m "Edit issue #${id}" "$id" && info "Issue #${id} saved."
}
# }}}

trap 'git_issue_restore_branch' EXIT

if [ $# -eq 0 ]
then
    usage
else
    cmd="$1"
    shift
    git_issue_parse_args $*
    shift $((OPTIND-1))

    function_exists "git_issue_${cmd}" || die "git issue $cmd doesn't exist"

    [ $cmd != 'help' -a $cmd != 'init' ] && git_issue_switch_branch
    git_issue_${cmd} $*
fi
